<context>
# Overview
Collector Service readiness remains 503 after boot when a dependency (Analysis Service) is initially unhealthy, because readiness is set to false during startup and never re-evaluated. This PRD proposes a resilient readiness design that continuously rechecks dependencies in the background and flips readiness to true once all are healthy, without requiring container restarts.

Why valuable:
- Improves startup stability and reduces manual restarts
- Prevents cascading failures and unnecessary restarts in Compose/Orchestrators
- Aligns with 12-Factor and observability-first practices

Target environment: Local Docker Compose (production compose), no cluster orchestrator.
Constraints:
- 12-Factor: configuration via env vars only
- IaC: changes applied via docker-compose.production.yml
- No secrets in repo; .env.example only
- Deterministic behavior (no random jitter)

# Core Features
- Dynamic readiness background watcher in `BACKEND-COLLECTOR-SERVICE/app/main.py`
- Dependency probe for Analysis/DB/Redis with deterministic backoff
- `/ready` returns current dependency states and attempts
- Compose healthcheck tuned with start_period/interval/retries to absorb initial delays
- Optional Prometheus metrics for readiness flips (enhancement)

# User Experience
- Operator runs `docker compose -f docker-compose.production.yml up -d`
- `curl http://localhost:8002/ready` transitions from 503 to 200 once deps healthy
- API Gateway `/health` reflects healthy collector without manual restart
</context>
<PRD>
# Technical Architecture
- Components
  - `BACKEND-COLLECTOR-SERVICE/app/main.py`:
    - Add background task `readiness_reconciler()` started on startup
    - Periodically probes dependencies (DB, Redis, Analysis)
    - Updates `app.state.ready` and `app.state.dep_status`
  - Dependency health checks
    - DB: attempt short connect using SQLAlchemy engine or ping
    - Redis: PING
    - Analysis: `GET {ANALYSIS_SERVICE_URL}/health` with timeout
- Config (env)
  - `READINESS_RECONCILE_INTERVAL_SECONDS` (default: 5)
  - `READINESS_INITIAL_GRACE_SECONDS` (default: 20)
  - `READINESS_BACKOFF_MAX_SECONDS` (default: 30)
  - All via `pydantic-settings` in `app/config.py`
- Deterministic backoff
  - Use monotonic time and capped linear/exponential without randomness
- API
  - `GET /ready` → `{ready: bool, dependencies: {db, redis, analysis}, attempts: {...}, last_change: iso}`
  - `GET /health` remains a simple process liveness check
- Infrastructure (Compose)
  - `docker-compose.production.yml`
    - `collector-service.healthcheck.test: ["CMD","curl","-f","http://localhost:8002/ready"]`
    - Add `start_period: 40s`, `interval: 5s`, `retries: 10`, `timeout: 3s`

# Development Roadmap
- MVP
  - Implement background readiness reconciler (loop + probes)
  - Surface current dependency states in `/ready`
  - Compose healthcheck tuning as above
  - Add structured logs for state transitions
- Hardening
  - Add Prometheus counter/gauge for readiness flips (optional `/metrics`)
  - Add circuit-breaker window to avoid flapping (require N consecutive successes)
  - Integration test: start collector with analysis down, bring analysis up → `/ready` becomes 200 within SLA
- Documentation
  - Update `DOCUMENTS/FINAL-IMPLEMENTATION-SUMMARY.md`
  - Update `DOCUMENTS/implementation-progress.md`

# Logical Dependency Chain
1) Code changes in `app/main.py` and `app/config.py`
2) Compose healthcheck tuning in `docker-compose.production.yml`
3) Integration test scripts update (`quick-test.sh`, `docker-test-and-stability.sh`)
4) Observability metrics (optional)
5) Docs updates

# Risks and Mitigations
- Readiness flapping → require consecutive successes (e.g., 3) before READY=true
- Excessive probe load → cap interval/backoff, short timeouts
- False positives → parse explicit 200 codes and strict timeouts; log details

# Acceptance & Validation Checklist
- [ ] After `analysis-service` becomes healthy, `collector-service` `/ready` returns 200 within 60s (PASS/FAIL with timestamp evidence)
- [ ] `docker compose ps` shows `collector-service-prod` healthy without restart loop (PASS/FAIL)
- [ ] API Gateway `/health` reports collector status healthy (PASS/FAIL)
- [ ] No randomness used in backoff; behavior is deterministic (PASS/FAIL)
- [ ] Env-only configuration; no secrets committed (PASS/FAIL)

# Appendix
- Example probe endpoints:
  - DB: SQLAlchemy `engine.connect()` with 1s timeout
  - Redis: `await redis.ping()` with 1s timeout
  - Analysis: `GET {ANALYSIS_SERVICE_URL}/health` with 2s timeout
- Example logs:
  - `READINESS: deps={"db":true,"redis":true,"analysis":false} attempts={...} ready=false`
  - `READINESS: deps all healthy; ready=true`
</PRD>
