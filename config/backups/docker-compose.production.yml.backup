version: '3.8'

services:
  # ===========================================
  # Infrastructure Services
  # ===========================================
  
  postgres:
    image: pgvector/pgvector:pg16
    container_name: postgres-prod
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?required}
      POSTGRES_DB: ${POSTGRES_DB:-pension_sentiment}
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --locale=C"
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./init-scripts/postgres:/docker-entrypoint-initdb.d:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

  redis:
    image: redis:7-alpine
    container_name: redis-prod
    restart: always
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    ports:
      - "${REDIS_PORT:-6379}:6379"
    volumes:
      - redis-data:/data
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M

  mongo:
    image: mongo:7
    container_name: mongo-prod
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME:-admin}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD:?required}
      MONGO_INITDB_DATABASE: ${MONGO_DATABASE:-osint_data}
    ports:
      - "${MONGO_PORT:-27017}:27017"
    volumes:
      - mongo-data:/data/db
      - ./init-scripts/mongo:/docker-entrypoint-initdb.d:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

  # ===========================================
  # Core Microservices
  # ===========================================
  
  api-gateway:
    image: pension-api-gateway:latest
    build:
      context: ./BACKEND-API-GATEWAY
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=production
    container_name: api-gateway-prod
    restart: always
    environment:
      # Service Configuration
      SERVICE_NAME: api-gateway
      SERVICE_VERSION: 1.0.0
      PORT: 8000
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      
      # Database
      DATABASE_URL: ${DATABASE_URL:?required}
      REDIS_URL: redis://redis:6379/0
      
      # Service URLs
      ANALYSIS_SERVICE_URL: http://analysis-service:8001
      COLLECTOR_SERVICE_URL: http://collector-service:8002
      ABSA_SERVICE_URL: http://absa-service:8003
      ALERT_SERVICE_URL: http://alert-service:8004
      OSINT_ORCHESTRATOR_URL: http://osint-orchestrator:8005
      OSINT_PLANNING_URL: http://osint-planning:8006
      OSINT_SOURCE_URL: http://osint-source:8007
      
      # Security
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:?required}
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8080}
      
      # HTTP Client Settings
      CONNECT_TIMEOUT: 2
      READ_TIMEOUT: 5
      MAX_RETRIES: 3
      CIRCUIT_BREAKER_ENABLED: true
    ports:
      - "${GATEWAY_PORT:-8000}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  analysis-service:
    image: pension-analysis:latest
    build:
      context: ./BACKEND-ANALYSIS-SERVICE
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=production
    container_name: analysis-service-prod
    restart: always
    environment:
      SERVICE_NAME: analysis-service
      SERVICE_VERSION: 1.0.0
      PORT: 8001
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      DATABASE_URL: ${DATABASE_URL:?required}
      REDIS_URL: redis://redis:6379/1
      
      # ML Model Settings
      MODEL_PATH: /app/models
      MODEL_VERSION: ${MODEL_VERSION:-v1.0.0}
      
      # Performance
      WORKERS: ${ANALYSIS_WORKERS:-4}
      BATCH_SIZE: ${BATCH_SIZE:-32}
    ports:
      - "${ANALYSIS_PORT:-8001}:8001"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ml-models:/app/models
      - ./shared:/app/shared:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 120s
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 1G
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  collector-service:
    image: pension-collector:latest
    build:
      context: ./BACKEND-COLLECTOR-SERVICE
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=production
    container_name: collector-service-prod
    restart: always
    environment:
      SERVICE_NAME: collector-service
      SERVICE_VERSION: 1.0.0
      PORT: 8002
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      DATABASE_URL: ${DATABASE_URL:?required}
      REDIS_URL: redis://redis:6379/2
      ANALYSIS_SERVICE_URL: http://analysis-service:8001
      
      # Crawler Settings
      CRAWLER_USER_AGENT: ${CRAWLER_USER_AGENT:-PensionCollectorBot/1.0}
      CRAWLER_TIMEOUT: ${CRAWLER_TIMEOUT:-30}
      CRAWLER_MAX_RETRIES: ${CRAWLER_MAX_RETRIES:-3}
      
      # Collection Settings
      COLLECTION_INTERVAL: ${COLLECTION_INTERVAL:-3600}  # 1 hour
      MAX_CONCURRENT_CRAWLS: ${MAX_CONCURRENT_CRAWLS:-10}
    ports:
      - "${COLLECTOR_PORT:-8002}:8002"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      analysis-service:
        condition: service_started
    volumes:
      - ./shared:/app/shared:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8002/ready"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 90s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  absa-service:
    image: pension-absa:latest
    build:
      context: ./BACKEND-ABSA-SERVICE
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=production
    container_name: absa-service-prod
    restart: always
    environment:
      SERVICE_NAME: absa-service
      SERVICE_VERSION: 1.0.0
      PORT: 8003
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      DATABASE_URL: ${DATABASE_URL:?required}
      REDIS_URL: redis://redis:6379/3
      ANALYSIS_SERVICE_URL: http://analysis-service:8001
      
      # NLP Model Settings
      NLP_MODEL: ${NLP_MODEL:-klue/bert-base}
      SENTIMENT_THRESHOLD: ${SENTIMENT_THRESHOLD:-0.75}
      
      # Korean NLP
      USE_KONLPY: ${USE_KONLPY:-true}
      KOREAN_DICT_PATH: /app/dictionaries/korean
    ports:
      - "${ABSA_PORT:-8003}:8003"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - nlp-models:/app/models
      - korean-dict:/app/dictionaries/korean
      - ./shared:/app/shared:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8003/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 1G
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  alert-service:
    image: pension-alert:latest
    build:
      context: ./BACKEND-ALERT-SERVICE
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=production
    container_name: alert-service-prod
    restart: always
    environment:
      SERVICE_NAME: alert-service
      SERVICE_VERSION: 1.0.0
      PORT: 8004
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      DATABASE_URL: ${DATABASE_URL:?required}
      REDIS_URL: redis://redis:6379/4
      
      # Alert Settings
      ALERT_CHECK_INTERVAL: ${ALERT_CHECK_INTERVAL:-60}  # seconds
      ALERT_BATCH_SIZE: ${ALERT_BATCH_SIZE:-100}
      
      # Notification Settings
      SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER:-}
      SMTP_PASSWORD: ${SMTP_PASSWORD:-}
      
      # Webhook Settings
      SLACK_WEBHOOK_URL: ${SLACK_WEBHOOK_URL:-}
    ports:
      - "${ALERT_PORT:-8004}:8004"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./shared:/app/shared:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8004/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # ===========================================
  # OSINT Services
  # ===========================================
  
  osint-orchestrator:
    image: pension-osint-orchestrator:latest
    build:
      context: ./BACKEND-OSINT-ORCHESTRATOR-SERVICE
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=production
    container_name: osint-orchestrator-prod
    restart: always
    environment:
      SERVICE_NAME: osint-orchestrator
      SERVICE_VERSION: 1.0.0
      PORT: 8005
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      DATABASE_URL: ${DATABASE_URL:?required}
      REDIS_URL: redis://redis:6379/5
      MONGO_URL: ${MONGO_URL:?required}
      
      # Service URLs
      PLANNING_SERVICE_URL: http://osint-planning:8006
      SOURCE_SERVICE_URL: http://osint-source:8007
      
      # Task Queue Settings
      TASK_QUEUE_NAME: osint_tasks
      MAX_CONCURRENT_TASKS: ${MAX_CONCURRENT_TASKS:-20}
    ports:
      - "${OSINT_ORCHESTRATOR_PORT:-8005}:8005"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      mongo:
        condition: service_healthy
    volumes:
      - ./shared:/app/shared:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8005/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

  osint-planning:
    image: pension-osint-planning:latest
    build:
      context: ./BACKEND-OSINT-PLANNING-SERVICE
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=production
    container_name: osint-planning-prod
    restart: always
    environment:
      SERVICE_NAME: osint-planning
      SERVICE_VERSION: 1.0.0
      PORT: 8006
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      DATABASE_URL: ${DATABASE_URL:?required}
      REDIS_URL: redis://redis:6379/6
      
      # Planning Settings
      PLANNING_HORIZON: ${PLANNING_HORIZON:-7}  # days
      PRIORITY_ALGORITHM: ${PRIORITY_ALGORITHM:-weighted}
    ports:
      - "${OSINT_PLANNING_PORT:-8006}:8006"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./shared:/app/shared:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8006/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M

  osint-source:
    image: pension-osint-source:latest
    build:
      context: ./BACKEND-OSINT-SOURCE-SERVICE
      dockerfile: Dockerfile
      args:
        - BUILD_ENV=production
    container_name: osint-source-prod
    restart: always
    environment:
      SERVICE_NAME: osint-source
      SERVICE_VERSION: 1.0.0
      PORT: 8007
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      DATABASE_URL: ${DATABASE_URL:?required}
      REDIS_URL: redis://redis:6379/7
      MONGO_URL: ${MONGO_URL:?required}
      
      # Source Management
      SOURCE_REFRESH_INTERVAL: ${SOURCE_REFRESH_INTERVAL:-3600}
      MAX_SOURCES_PER_TYPE: ${MAX_SOURCES_PER_TYPE:-100}
    ports:
      - "${OSINT_SOURCE_PORT:-8007}:8007"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      mongo:
        condition: service_healthy
    volumes:
      - ./shared:/app/shared:ro
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8007/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

  # ===========================================
  # Frontend Service
  # ===========================================
  
  frontend:
    image: pension-frontend:latest
    build:
      context: ./FRONTEND-DASHBOARD
      dockerfile: Dockerfile
      args:
        - REACT_APP_API_URL=${REACT_APP_API_URL:-http://localhost:8000}
        - BUILD_ENV=production
    container_name: frontend-prod
    restart: always
    environment:
      - NODE_ENV=production
      - REACT_APP_API_URL=${REACT_APP_API_URL:-http://localhost:8000}
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    depends_on:
      - api-gateway
    networks:
      - production-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M

  # ===========================================
  # Monitoring Services (Optional)
  # ===========================================
  
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus-prod
    restart: always
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    ports:
      - "${PROMETHEUS_PORT:-9090}:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    networks:
      - production-network
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M

  grafana:
    image: grafana/grafana:latest
    container_name: grafana-prod
    restart: always
    environment:
      - GF_SECURITY_ADMIN_USER=${GF_ADMIN_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD=${GF_ADMIN_PASSWORD:?required}
      - GF_INSTALL_PLUGINS=grafana-piechart-panel
    ports:
      - "${GRAFANA_PORT:-3001}:3000"
    volumes:
      - grafana-data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning:ro
    depends_on:
      - prometheus
    networks:
      - production-network
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M

networks:
  production-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16

volumes:
  postgres-data:
  redis-data:
  mongo-data:
  ml-models:
  nlp-models:
  korean-dict:
  prometheus-data:
  grafana-data:
